#!/usr/bin/env python3
"""
cryptfile
=========

Do things with LUKS and files.

When mounting a loop device with crypsetup, the same name as the loop device
itself will be chosen. This means /dev/loopN (encrypted) will be made available
as /dev/mapper/loopN (plaintext).
"""

from __future__ import print_function
from sys import stderr

from subprocess import call, check_call, check_output
from os.path import exists, abspath
from os import stat


FS = 'ext2'
MAKEFS = 'mkfs.' + FS
FSCK = 'fsck.' + FS
RESIZEFS = 'resize2fs'


#
# Utilities
#

COMMAND_PREPEND = []

def _check_call(args):
    cmd = COMMAND_PREPEND + args
    print('\033[37m>', *cmd, end='\033[0m\n')
    return check_call(cmd)


def _check_output(args):
    cmd = COMMAND_PREPEND + args
    return check_output(cmd)


def _call(args):
    cmd = COMMAND_PREPEND + args
    print('\033[37m>', *cmd, end='\033[0m\n')
    return call(cmd)


def lo2cs(loop):
    """Extract the loop device name for use with cryptsetup."""
    name = loop.rsplit('/', 1)[-1]
    return '/dev/mapper/' + name


unit_multiply = {
    'K': 1024,
    'M': 1024**2,
    'G': 1024**3,
    'T': 1024**4,
    'KB': 1000,
    'MB': 1000**2,
    'GB': 1000**3,
    'TB': 1000**4,
}


def size_as_bytes(sz):
    """Convert human readable units to bytes"""
    for i, c in enumerate(sz):
        if not c.isdigit():
            unit = sz[i:].upper()
            return int(sz[:i]) * unit_multiply[unit]
    return int(sz)



#
# Filesystem tools
#


def lo_mount(image):
    """Mount the given file on a loop device."""
    loop = check_output(['losetup', '-f']).decode().rstrip()
    _check_call(['losetup', loop, image])
    return loop


def lo_umount(loop):
    """Unmount the given loop device."""
    _check_call(['losetup', '-d', loop])


def fs_umount(path):
    """Unmount the given path."""
    _check_call(['umount', path])


def cs_umount(loop):
    """Close the given crypt device."""
    r = _call(['cryptsetup', 'luksClose', lo2cs(loop)])
    if r == 4:
        # Device wasn't open
        print('Non-fatal error: luksClose exit code', r, file=stderr)
    elif r != 0:
        raise ValueError('luksClose exit code %r' % (r,))
    return r


def lo_fs_umount(loop):
    """Unmount the plaintext device associated with the given loop device."""
    path = lo2cs(loop)
    mount = fs_find(path)
    if mount:
        fs_umount(mount)


def umount(path=None, loop=None):
    """Unmount everything."""
    if not loop:
        loop = lo_find(path)

    if not loop:
        return

    lo_fs_umount(loop)
    cs_umount(loop)
    lo_umount(loop)



def lo_find(image):
    """Find the loop device associated with the given file."""
    match = ' (' + abspath(image) + ')'  # Probably not always OK..
    lo_mounts = _check_output(['losetup', '--all']).decode().split('\n')
    for m in lo_mounts:
        if m.endswith(match):
            # Loop device path
            return m.split(':', 1)[0]

    # Not mounted


def fs_find(dev):
    """Find the filesystem path associated with the given device and return
    the mount point."""
    for line in open('/proc/mounts'):
        parts = line.split(' ', 2)
        if parts[0] == dev:
            return parts[1]



def cs_open(loop):
    """Open a crypt device for the given loop device."""
    cs = lo2cs(loop)

    if not exists(cs):
        name = cs.rsplit('/', 1)[-1]
        _check_call(['cryptsetup', 'luksOpen', loop, name])

    return cs


#
# Commands
#

def cryptfile_mount(image_path, mount_point):
    """
    cryptfile mount example.img mnt
    """
    loop = lo_find(image_path)
    if not loop:
        loop = lo_mount(image_path)

    mount = fs_find(lo2cs(loop))
    if mount:
        print('# Already mounted')
        print(mount)
        return

    cs = cs_open(loop)
    _check_call(['mount', cs, mount_point])
    print(mount_point)


def cryptfile_format(image_path, fs_size, force='no'):
    """
    cryptfile format example.img 32M
    """
    if exists(image_path) and force != 'yes':
        raise ValueError('Not formatting existing file %r' % (image_path,))

    size_as_bytes(fs_size)
    umount(image_path)
    _check_call(['truncate', '-s', fs_size, '--', image_path])
    loop = lo_mount(image_path)
    cs = lo2cs(loop)
    _check_call(['cryptsetup', 'luksFormat', loop])
    name = cs.rsplit('/', 1)[-1]
    _check_call(['cryptsetup', 'luksOpen', loop, name])
    _check_call([MAKEFS, cs])


def cryptfile_umount(image_path):
    """
    cryptfile umount example.img
    """
    umount(image_path)


def cryptfile_resize(image_path, new_size):
    """
    cryptfile resize example.img 64M

    * When shrinking, size should be either K, M, or G
    * Will potentially eat your filesystem
    """

    raise NotImplementedError('This code does not work yet.')

    old_bytes = stat(image_path).st_size
    new_bytes = size_as_bytes(new_size)

    loop = lo_find(image_path)

    if old_bytes == new_bytes:
        print('Already correct size')
        return

    elif old_bytes < new_bytes:
        print('Increasing file size')

        umount(loop=loop)
        _check_call(['truncate', '-s', new_size, '--', image_path])
        loop = lo_mount(image_path)
        cs = cs_open(loop)
        _check_call([FSCK, '-f', cs])
        _check_call([RESIZEFS, cs])
        umount(loop=loop)
    else:
        print('Reducing file size')

        if loop:
            lo_fs_umount(loop)
        else:
            loop = lo_mount(image_path)

        cs = cs_open(loop)
        _check_call([FSCK, '-f', cs])
        _check_call([RESIZEFS, cs, new_size])
        umount(loop=loop)

        _check_call(['truncate', '-s', new_size, '--', image_path])


if __name__ == '__main__':
    from sys import argv
    from os import geteuid


    commands = {
        'mount': cryptfile_mount,
        'umount': cryptfile_umount,
        'format': cryptfile_format,
        'resize': cryptfile_resize,
    }

    if not argv[1:] or argv[1] not in commands:
        print('Available commands:', sorted(commands.keys()))
        exit(1)

    if geteuid() != 0:
        # TODO: this doesn't work if losetup is in /usr/sbin and that is not
        # in your $PATH, unless sudo adds this path.
        COMMAND_PREPEND = ['sudo']
        print('Hint: you probably want to use sudo. Trying it...')

    commands[argv[1]](*argv[2:])
